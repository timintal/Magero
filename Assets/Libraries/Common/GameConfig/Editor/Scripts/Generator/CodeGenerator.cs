using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.Config.Model
{
    public class CodeGenerator
    {
        
        private const string classTemplate = @"//
// AUTOGENERATED - DO NOT MODIFY.
//

namespace Game.Config.Model
{
    public class {className}Model : IConfigModel
    {
        public string Id => id;
{properties}

        protected string id;
{fields}
    }
}";
        public static object GetTypedValue(string type, string stringValue, out bool validParse)
        {
            validParse = true;
            switch (type)
            {
                case "bool":
                    var lowercaseValue = stringValue.ToLower();
                    if (lowercaseValue == "true" || lowercaseValue == "false")
                        return lowercaseValue == "true";
                    else
                    {
                        validParse = false;
                        Debug.LogWarning(
                            $"[ConfigUtils.GetConfigTypedValue] stringValue {stringValue} is not of type {type}");
                        return false;
                    }
                case "int":
                    int intValue;
                    if (int.TryParse(stringValue, out intValue))
                        return intValue;
                    else
                    {
                        validParse = false;
                        Debug.LogWarning(
                            $"[ConfigUtils.GetConfigTypedValue] stringValue {stringValue} is not of type {type}");
                        return 0;
                    }
                case "float":
                    float floatValue;
                    if (float.TryParse(stringValue, out floatValue))
                        return floatValue;
                    else
                    {
                        validParse = false;
                        Debug.LogWarning(
                            $"[ConfigUtils.GetConfigTypedValue] stringValue {stringValue} is not of type {type}");
                        return 0f;
                    }
                default:
                    return stringValue;
            }
        }

        public string GenerateCode(IList<IList<object>> data, string sheetTitle,
            Dictionary<int, ConfigColumn> configModelColumns, List<int> skipColumns, Dictionary<string, string> sheetJsonDataMap)
        {
            if (data == null)
            {
                return $"sheet {sheetTitle} contains no data";
            }

            if (data.Count < 2)
            {
                return $"sheet {sheetTitle} should have at least two rows for property ids and types";
            }
            
            var structure = new Dictionary<string, object>();
            var items = new List<Dictionary<string, object>>();
            var outputData = new Dictionary<string, object>
            {
                {"name", sheetTitle},
                {"structure", structure},
                {"items", items}
            };
            
            var alphanumericRegex = new Regex(@"^[a-zA-Z0-9_]*$");

            configModelColumns.Clear();
            skipColumns.Clear();
            for (var i = 0; i < data.Count; i++)
            {
                var rowIndex = i + 1;
                var row = data[i];
                if (row.Count == 0)
                {
                    return $"sheet {sheetTitle} should have at least one column for item ids";
                }

                for (var j = 0; j < row.Count; j++)
                {
                    var columnIndex = j + 1;
                    var cellValue = row[j].ToString();
                    if (SkipColumn(cellValue,skipColumns,i, j))
                        continue;
                   
                    var error = CodeGenerationValidator.ValidateColumn(sheetTitle, configModelColumns,  i, cellValue, j, columnIndex, alphanumericRegex, rowIndex);
                    if (!string.IsNullOrEmpty(error))
                    {
                        return error;
                    }
                    ProcessColumn(configModelColumns, i, j, cellValue);
                }
            }

            foreach (var configModelColumn in configModelColumns.Values)
            {
                if (configModelColumn.Type == null)
                {
                    return $"null config model property {configModelColumn.Id} type in sheet {sheetTitle}";
                }

                structure.Add(configModelColumn.Id, configModelColumn.Type);
            }

            var idConfigColumn = configModelColumns[0];
            foreach (var index in idConfigColumn.Values.Keys)
            {
                var item = new Dictionary<string, object>();
                foreach (var configModelColumn in configModelColumns.Values)
                {
                    if (configModelColumn.HasValue(index))
                        item.Add(configModelColumn.Id, configModelColumn.GetValue(index));
                }

                items.Add(item);
            }

            var jsonData = JsonConvert.SerializeObject(outputData, Formatting.None);
            sheetJsonDataMap.Add(sheetTitle, jsonData);

            GenerateCsClass(sheetTitle, configModelColumns);
            return "";
        }


        private bool SkipColumn(string cellValue, List<int> skipColumns, int i, int j)
        {
            if (i != 0)
            {
                return skipColumns.Contains(j);
            }
            var needsSkip = cellValue.StartsWith(ConfigModelConstants.CommentSymbol);
            if (needsSkip)
            {
                skipColumns.Add(j);
            }
            return needsSkip;
        }
        
        private static void ProcessColumn(Dictionary<int, ConfigColumn> configModelColumns, int i, int j, string cellValue)
        {
            if (i == 0)
                configModelColumns.Add(j, new ConfigColumn(j, cellValue));
            else if (i == 1)
                configModelColumns[j].SetType(cellValue);
        }

        private void GenerateCsClass(string sheetTitle, Dictionary<int, ConfigColumn> configModelColumns)
        {
            var className = sheetTitle;
            var classCode = classTemplate;
            var propertyCode = string.Empty;
            var fieldCode = string.Empty;
            classCode = classCode.Replace("{className}", className);
            foreach (var configModelColumn in configModelColumns.Values)
            {
                if (configModelColumn.Id == "id") continue;
                propertyCode += $"        {configModelColumn.GetPropertyCode()}" + Environment.NewLine;
                fieldCode += $"        {configModelColumn.GetFieldCode()}" + Environment.NewLine;
            }

            classCode = classCode.Replace("{properties}", propertyCode);
            classCode = classCode.Replace("{fields}", fieldCode);

            File.WriteAllText(Path.Combine(ConfigPaths.ConfigModelClassPath, $"{className}Model.cs"), classCode);
        }

    }
}